MongoDB Aggregation Pipeline in Go


Run Database query with one-go

The database transaction to retrieve a large number of records in a single query is a daunting task. The millions of 
documents stored in the database have complex relationships with data nodes that require seamless flow with the software 
application service. The data node defines the business data processing workloads to perform an intensive task in real-time. 
The business software applications (Stock Market, Disaster Management, a Cryptocurrency marketplace, Census dashboard) 
require in-flight analytical data with a single database query to retrieve grouped data and a faster business transaction 
timeline. 

Techniques to handle large datasets

MongoDB provides data processing functions to analyze large datasets and produce the final aggregated results. The Map Reduce 
and Aggregation pipeline are 2 ways of aggregating, grouping, filtering data nodes in MongoDB with several functional stages.

-  What is Map-Reduce?
    Map Reduce is a javascript functional model to map documents with emit(key-value) pair based function and the reduce
    function performs the aggregation of the data node that returns the output to the client. 

    -- Structure of Map-Reduce in MongoDB
       MongoDB uses "mapReduce" database command for a collection to apply the aggregation for a query. The map-reduce 
       function faciliate to write computational logic for a data node under map function and emit the key-value result to
       reduce function for finializing the resultant document.  
       
    For example: A "mapReduce" function to count number of imdb votes for a movie stored under a collection.

    <<-- screenshot movie list -->>

    db.movies.mapReduce(
        // map
        function(){
            emit(1,this.imdb.votes);
        }, 

        // reduce
        function(key,vals){ 
            var count = 0;
            vals.forEach(function(v) {
                count +=v;
            });

            return count;
        }, 
        {  
            // query  
            query: {
                "imdb.rating": {
                    "$lt": 7.5
                }
            }, 
            // output
            out: "vote_count" 
        }
    ).find();


- What is Aggregation pipeline?

    The Aggregation pipeline works as a data processing framework in MongoDB to aggregate hierarchical data 
nodes. There will be several stages to process the documents that pass through a pipeline to filter out the 
final analyzed document. The pipeline operators used to apply logical queries and accumulate the filtered 
documents to transform an output structure. The performance of the aggregation pipeline is significantly high 
compared to Map-Reduce because the framework runs with compiled C++ codes. The data flow control works as a 
sequence of stages that the output of the previous stage becomes the input to the next stage. In each stage, 
the pipeline operator decides the type of aggregation action to perform in the database engine. 

- How to write Aggregation pipeline?
The pipeline written as BSON format passes directly into the "aggregate()" function in the Mongo Shell for 
executing the aggregation query. Also, MongoDB provides language-specific drivers that will have an in-built 
Aggregation framework with structure API functions to implement the Aggregation pipeline in the application. 

The following "aggregate" function count the total votes using aggregation pipeline. In the first stage, 
the "$match" operator applies a conditional query to filter the documents with less than 7.5 "imdb.rating". 
Then the second stage takes the filtered document as input to accumulate the $sum of "imdb.votes" and groups 
the vote_count using $group operator. 

    db.movies.aggregate(

        // Pipeline
        [
            // Stage 1
            {
                $match: {
                    // conditional query 
                    "imdb.rating": {
                        "$lt": 7.5
                    }
                }
            },

            // Stage 2
            {
                $group: {
                    _id: "total_vote",
                    vote_count: { 
                        "$sum": "$imdb.votes"
                    }
                }
            },
        ]
    );

    Analyzing Explain Plan

    The performance measurement of the aggregation query is fully analyzed using explain plan. 
    As an internal layer, the aggregation framework uses MongoDB Query Language (MQL) to execute the query. 
    In the process of optimizing the aggregation query database engine reorders the pipeline stages and 
    embeds the $cursor operator as the first stage of the pipeline to decide to pick the best possible 
    winning plan for stages. The winningPlan will form the metadata like the type of document scan 
    [IXSCAN, COLLSCAN, FETCH] operation for the stages that will be used to retrieve the document faster.

    Visualizing Aggregation flow in Studio 3T

    In Studio 3T, the transactional flow shows the total time to produce the result and the size of the 
    documents generated in each stage of the pipeline. The explain query in Studio 3T quite useful to 
    visualize the process for an aggregation pipeline.
    
    << -- screenshot of aggregation flow -- >>
    


