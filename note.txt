MongoDB Aggregation Pipeline in Go


Run Database query with one-go

The database transaction to retrieve a large number of records in a single query is a daunting task. The millions of 
documents stored in the database have complex relationships with data nodes that require seamless flow with the software 
application service. The data node defines the business data processing workloads to perform an intensive task in real-time. 
The business software applications (Stock Market, Disaster Management, a Cryptocurrency marketplace, Census dashboard) 
require in-flight analytical data with a single database query to retrieve grouped data and a faster business transaction 
timeline. 

Techniques to handle large datasets

MongoDB provides data processing functions to analyze large datasets and produce the final aggregated results. The Map Reduce 
and Aggregation pipeline are 2 ways of aggregating, grouping, filtering data nodes in MongoDB with several functional stages.

-  What is Map-Reduce?
    Map Reduce is a javascript functional model to map documents with emit(key-value) pair based function and the reduce
    function performs the aggregation of the data node that returns the output to the client. 

    -- Structure of Map-Reduce in MongoDB
       MongoDB uses "mapReduce" database command for a collection to apply the aggregation for a query. The map-reduce 
       function faciliate to write computational logic for a data node under map function and emit the key-value result to
       reduce function for finializing the resultant document.  
       
    For example: A "mapReduce" function to count number of imdb votes for a movie stored under a collection.

    <<-- screenshot movie list -->>

    db.movies.mapReduce(
        // map
        function(){
            emit(1,this.imdb.votes);
        }, 

        // reduce
        function(key,vals){ 
            var count = 0;
            vals.forEach(function(v) {
                count +=v;
            });

            return count;
        }, 
        {  
            // query  
            query: {
                "imdb.rating": {
                    "$lt": 7.5
                }
            }, 
            // output
            out: "vote_count" 
        }
    ).find();


- What is Aggregation pipeline?

    The Aggregation pipeline works as a data processing framework in MongoDB to aggregate hierarchical data 
nodes. There will be several stages to process the documents that pass through a pipeline to filter out the 
final analyzed document. The pipeline operators used to apply logical queries and accumulate the filtered 
documents to transform an output structure. The performance of the aggregation pipeline is significantly high 
compared to Map-Reduce because the framework runs with compiled C++ codes. The data flow control works as a 
sequence of stages that the output of the previous stage becomes the input to the next stage. In each stage, 
the pipeline operator decides the type of aggregation action to perform in the database engine. 

- How to write Aggregation pipeline?
The pipeline written as BSON format passes directly into the "aggregate()" function in the Mongo Shell for 
executing the aggregation query. Also, MongoDB provides language-specific drivers that will have an in-built 
Aggregation framework with structure API functions to implement the Aggregation pipeline in the application. 

The following "aggregate" function count the total votes using aggregation pipeline. In the first stage, 
the "$match" operator applies a conditional query to filter the documents with less than 7.5 "imdb.rating". 
Then the second stage takes the filtered document as input to accumulate the $sum of "imdb.votes" and groups 
the vote_count using $group operator. 

    db.movies.aggregate(

        // Pipeline
        [
            // Stage 1
            {
                $match: {
                    // conditional query 
                    "imdb.rating": {
                        "$lt": 7.5
                    }
                }
            },

            // Stage 2
            {
                $group: {
                    _id: "total_vote",
                    vote_count: { 
                        "$sum": "$imdb.votes"
                    }
                }
            },
        ]
    );

    Complex Aggregation Pipelines

    The MongoDB aggregation framework has many operators that support to aggregate in the pipeline stages. 
    The operators are treated as MongoDB query commands to perform query actions and then either process the 
    pipeline into the next available stage or collect the filtered document at the final pipeline stage. 
    The pipeline execution is an algorithmic process of a finite sequence of blocking structures that perform
    several aggregation functions.

    - sorting, merging of documents from more one collection.
    - Arithmatic computation of numeric data nodes. 
    - Accumulate a data node to apply Mongo aggregation expression ($avg, $sum, $addField, $concat).
    - Apply GeoSpatial command to find near by address or calculate min/max distance.
    - and many more

    Type of Aggregation Pipeline Operators

    - $project
      In the collection of documents, sometimes of their won't be need to fetch all data items. The performance
    of query improved with selecting neccessary field of documents.

    Example:

    There is a simple movie details collection and only specific fields 'title', 'plot', 'year', 'rating' required
    to be retrieve from the collection.

    {
        "_id": ObjectId("573a1391f29313caabcd8b94"),
        "title": "The Last Command",
        "plot": "A former Imperial Russian general and cousin of the Czar ends up in Hollywood as an 
        extra in a movie directed by a former revolutionary.",
        "rated": "GOOD",
        "language": "Russian",
        "year": 1928,
        "poster": "https://m.media-amazon.com/images/M/MV5BMTg2Mjg3MDI5OF5BMl5BanBnXkFtZTgwMjMzMDMyMjE@._V1_SY1000_SX677_AL_.jpg",
        "director": "Josef von Sternberg",
        "awards": {
            "wins": 2,
            "nominations" : 1,
            "result": "Won 1 Oscar. Another 1 win & 1 nomination."
        },
        "imdb": {
            "rating": 8,
            "votes": 2090,
            "id": 19071
        },
        "genres": ["Drama", "History", "War"]
    }

    $project aggregation query

    db.movies.aggregate([{
        $project: {
            _id: 0, title: 1, plot: 1, year: 1, imdb.rating: 1
        }
    }]).pretty()

    result

    {
        "plot":"A former Imperial Russian general and cousin of the Czar ends up in Hollywood as an extra in 
            a movie directed by a former revolutionary.",
        "title":"The Last Command",
        "year":1928
    }

    - $group
    The distinct category of grouping documents followed by _id is supported by $group operator. The ouput field
    document holds the accumlated value of object. There are various accumulator expressions used in different scenarios.

    Example-1

    - Find the total number of votes for all the movies using $sum accumulator expression.

    list of movies:

    << Add 10 list of movies >>

    query: 

    db.movies.aggregate([{
        $group: {
            "_id": "total_votes",
            "count": {
                "$sum": "$imdb.votes"
            }
        }
    }])

    result: 
    { "_id" : "total_votes", "count" : 478794967 }

    Example-2

    - Find the recent movie document using "$last" accumulator expression with the genre "War".

    list of movies:

    << Add 10 list of movies >>

    query:

        db.movies.aggregate([
            // Stage - 1
            {
                $unwind: "$genres", // $unwind to deserialize the array of documents
            },
            // Stage - 2
            {
                $match: {
                    "genres": "War"           
                },
            },
            // Stage - 3
            {
                $group: {
                    "_id": "Movie",
                    "doc": {
                        "$last": "$$ROOT" // similar $first accumulator expression to retreive first movie doc
                    }
                },
            }
    ]).pretty()

    result:

    << output of the latest movie doc >>

    - $lookup
    The MongoDB stores the documents in multiple collection and also a good practice to distribute the records
    to reduce the storage volume for collection. The foreign key attribute to maintain relationship between collection
    with similar shared data items. 

    $lookup query structure

    -- Structure 1
    {
        $lookup:
            {
                from: <collection to join>,
                localField: <field from the input documents>,
                foreignField: <field from the documents of the "from" collection>,
                as: <output array field>
            }
    }

    -- Structure 2
    {
        $lookup:
            {
                from: <collection to join>,
                let: { <var_1>: <expression>, â€¦, <var_n>: <expression> },
                pipeline: [ <pipeline to run on joined collection> ],
                as: <output array field>
            }
    }


    list of movies:

    << Add 10 list of movies >>

    list of comments for the movie

    << Add 20 list of comments >>


    Example - 1:

    The list of comments for the movies stored in separate collection and requirement is to retreive movie comments
    with genres "Comedy" and "imdb.rating" greater than 5.

    query:

        db.movies.aggregate([
            // Stage - 1
            {
                $unwind: "$genres"
            },
            // Stage - 2
            {
                $match: { 
                    "genres": "Comedy",
                    "imdb.rating" : {
                        $gt: 5
                    }           
                }
            },
            // Stage - 3
            {
                $lookup: {
                    "from": "comments",
                    "localField": "_id",
                    "foreignField": "movie_id",
                    "as": "comments"
                }
            },
            // Stage - 4
            {
                
                $project: {
                    "_id": 0,
                    "comments": 1
                }
            }
        ]).pretty() 

    result:

    << list of movies with comments >>

    Example - 2:
    
    In this requirement to retrieve sorted with latest comment in ascending order. So, we need to apply $lookup 
    pipeline attribute to run sorting pipeline within the join collection.

    query:

        db.movies.aggregate([
            // Stage - 1
            {
                $unwind: "$genres"
            },
            // Stage - 2
            {
                $match: { 
                    "genres": "Comedy",
                    "imdb.rating" : {
                        $gt: 5
                    }           
                }
            },
            // Stage - 3
            {
                $lookup: {
                    "from": "comments",
                    "let": {
                        "movieId": {
                            "$toObjectId": "$_id"
                        }
                    },
                    "pipeline": [
                        {
                            $match: {
                                $expr: {
                                    $eq: ["$movie_id", "$$movieId"]
                                }
                            }
                        },
                        {
                            $sort : {
                                "date": -1
                            }					
                        }				
                    ],
                    "as": "comments"
                }
            },
            // Stage - 4
            {
                $project: {
                    "_id": 0,
                    "comments": 1
                }
            }
        ]).pretty()

    results:

    << list of sorted comments for the movie >>

    - $graphLookup
        MongoDB provides graph searching among collections with similar relationships. The recursive search 
    on the collection continues until the searching node is found or the defined levels of maxDepth have 
    reached the limit.

    $graphLookup query structure

    ---  
        {
            $graphLookup: {
                from: <collection to join>,
                startWith: <expression that begins the search>,
                connectFromField: <field name to map with `from` collection>,
                connectToField: <field name that map with aggregated collection>,
                as: <ouput object>,
                maxDepth: <defined level of depth to perform recursive search>
            }
        }


    - $geoNear
        MongoDB supports geolocation queries with $geoNear aggregator. There are plenty of use-cases on 
    geography coordinates to calculate nearby distances with the point. The GeoJSON coordinate pair work 
    well in the aggregation to point to the closet documents in the collection.

    Example :
        Find the nearby theaters within certain radius on given lat/long coordinates.

        << list of theaters >>
    
    query:
        db.theaters.aggregate([
            // Stage - 1
            {
                "$geoNear": {
                    "near": {
                        "type": "Point",
                        "coordinates": []interface{}{latC,longC},
                    },
                    "minDistance": 2,
                    "maxDistance": 200000,
                    "distanceField": "distance",
                    "includeLocs": "geo",
                    "spherical": true,
                },
            },
            // Stage - 2
            {
                "$project": bson.M{
                    "location.geo": 0,
                },
            }
        ])

    result: 

    


    Analyzing Explain Plan

    The performance measurement of the aggregation query is fully analyzed using explain plan. MongoDB supports
    three type of verbosity mode than can explain a query execution plan, queryPlanner, executionStats and 
    allPlansExecution. 
    
    As an internal layer, the aggregation framework uses MongoDB Query Language (MQL) to execute the query. 
    In the process of optimizing the aggregation query database engine reorders the pipeline stages and 
    embeds the $cursor operator as the first stage of the pipeline to decide to pick the best possible 
    winning plan for stages. The winningPlan will form the metadata to make a judgment call on type document
    scan operation [IXSCAN, COLLSCAN, FETCH] on stage for faster retreival of the documents.


    Explain with queryPlanner

    db.getCollection("movies").explain("queryPlanner").aggregate(pipeline)

    "stages" : [
        {
            "$cursor" : {
                "queryPlanner" : {
                    "namespace" : "movie_details.movies", 
                    "indexFilterSet" : false, 
                    "parsedQuery" : {
                        "imdb.rating" : {
                            "$lt" : 7.5
                        }
                    }, 
                    "queryHash" : "148454AD", 
                    "planCacheKey" : "42DB0972", 
                    "maxIndexedOrSolutionsReached" : false, 
                    "maxIndexedAndSolutionsReached" : false, 
                    "maxScansToExplodeReached" : false, 
                    "winningPlan" : {
                        "stage" : "PROJECTION_DEFAULT", 
                        "transformBy" : {
                            "imdb.votes" : 1.0, 
                            "_id" : 0.0
                        }, 
                        "inputStage" : {
                            "stage" : "COLLSCAN", // scan entire collection to match with the record
                            "filter" : {
                                "imdb.rating" : {
                                    "$lt" : 7.5
                                }
                            }, 
                            "direction" : "forward"
                        }
                    }, 
                    "rejectedPlans" : [

                    ]
                }
            }
        }, 
        {
            "$group" : {
                "_id" : {
                    "$const" : "total_vote"
                }, 
                "vote_count" : {
                    "$sum" : "$imdb.votes"
                }
            }
        }
    ]

    Here the "winningPlan" stage metadata is scanned with "COLLSCAN" operation, so the entire collection data 
    nodes require to iterate all rows and records to map/match with the particular records. The COLLSCAN is 
    pretty slow and very much ineffective mapping with an enormously large data set. The queryPlanner also 
    supports indexing with IXSCAN that doesn't need to perform an entire collection scan but an index filter 
    can instantly map with a particular record.


    Explain with executionStats
    
    The statistics of winning plan query execution contains in "executionStats" mode. 
    
    db.getCollection("movies").explain("executionStats").aggregate(pipeline)

    "stages" : [

            "executionStats" : {
                    "executionSuccess" : true, 
                    "nReturned" : 18511.0, 
                    "executionTimeMillis" : 42.0, 
                    "totalKeysExamined" : 0.0, 
                    "totalDocsExamined" : 23530.0, 
                    "executionStages" : {
                        "stage" : "PROJECTION_DEFAULT", 
                        "nReturned" : 18511.0, 
                        "executionTimeMillisEstimate" : 2.0, 
                        "works" : 23532.0, 
                        "advanced" : 18511.0, 
                        "needTime" : 5020.0, 
                        "needYield" : 0.0, 
                        "saveState" : 24.0, 
                        "restoreState" : 24.0, 
                        "isEOF" : 1.0, 
                        "transformBy" : {
                            "imdb.votes" : 1.0, 
                            "_id" : 0.0
                        }, 
                        "inputStage" : {
                            "stage" : "COLLSCAN", 
                            "filter" : {
                                "imdb.rating" : {
                                    "$lt" : 7.5
                                }
                            }, 
                            "nReturned" : 18511.0, 
                            "executionTimeMillisEstimate" : 1.0, 
                            "works" : 23532.0, 
                            "advanced" : 18511.0, 
                            "needTime" : 5020.0, 
                            "needYield" : 0.0, 
                            "saveState" : 24.0, 
                            "restoreState" : 24.0, 
                            "isEOF" : 1.0, 
                            "direction" : "forward", 
                            "docsExamined" : 23530.0
                        }
                    }
                }
            }, 
            "nReturned" : NumberLong(18511), 
            "executionTimeMillisEstimate" : NumberLong(29)
    ]


    nReturned: Number of document returned from the query, in this case 18511 movies returned to the client.

    executionTimeMillis: The query execution time in millisecond that helps to understand the performance of 
    the aggregation query.

    filter: The conditional query statement included in the aggregation pipeline. 
    
    "imdb.rating" : { "$lt" : 7.5 }

    docsExamined: Total document examined in the collection to match with particular searching record




    Visualizing Aggregation flow in Studio 3T

    In Studio 3T, the transactional flow shows the total time to produce the result and the size of the 
    documents generated in each stage of the pipeline. The explain query in Studio 3T quite useful to 
    visualize the process for an aggregation pipeline.
    
    << -- screenshot of aggregation flow -- >>
    


